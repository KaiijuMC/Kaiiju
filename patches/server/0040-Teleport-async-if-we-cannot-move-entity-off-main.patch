From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Sofiane H. Djerbi" <46628754+kugge@users.noreply.github.com>
Date: Sat, 8 Jul 2023 03:31:04 +0300
Subject: [PATCH] Teleport async if we cannot move entity off-main

Entities with huge velocity (100k+ velocity anarchy travel exploit) might disappear / crash the server because they travel a region each tick.
TODO: Entities with huge velocity still throw stacktraces because they are ticked in "null" regions.

diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 135573308662845ecc73fde1c620345e1f372538..3a8684ce5820dd766237ead4ba030f735e1484df 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1126,7 +1126,18 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                     }
                 }
 
+                try { // Kaiiju - Teleport async if we cannot move entity off-main
                 this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
+                // Kaiiju start - Teleport async if we cannot move entity off-main
+                } catch (IllegalStateException e) {
+                    this.teleportAsync((ServerLevel) this.level(), this.position().add(vec3d1),
+                                       this.getYRot(), this.getXRot(),
+                                       Vec3.ZERO, PlayerTeleportEvent.TeleportCause.UNKNOWN,
+                                       Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                                       null
+                    );
+                }
+                // Kaiiju end
             }
 
             this.level().getProfiler().pop();
@@ -3868,13 +3879,15 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         // check for same region
         if (destination == this.level()) {
             Vec3 currPos = this.position();
-            if (
-                destination.regioniser.getRegionAtUnsynchronised(
-                    io.papermc.paper.util.CoordinateUtils.getChunkX(currPos), io.papermc.paper.util.CoordinateUtils.getChunkZ(currPos)
-                ) == destination.regioniser.getRegionAtUnsynchronised(
-                    io.papermc.paper.util.CoordinateUtils.getChunkX(pos), io.papermc.paper.util.CoordinateUtils.getChunkZ(pos)
-                )
-            ) {
+            // Kaiiju start - We shouldn't teleport when regions are null
+            io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData,
+                                                                               io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
+            currRegion = destination.regioniser.getRegionAtUnsynchronised(io.papermc.paper.util.CoordinateUtils.getChunkX(currPos), io.papermc.paper.util.CoordinateUtils.getChunkZ(currPos));
+            io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData,
+                                                                               io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
+            destRegion = destination.regioniser.getRegionAtUnsynchronised(io.papermc.paper.util.CoordinateUtils.getChunkX(pos), io.papermc.paper.util.CoordinateUtils.getChunkZ(pos));
+            if (currRegion == destRegion && currRegion != null) {
+            // Kaiiju end
                 EntityTreeNode passengerTree = this.detachPassengers();
                 // Note: The client does not accept position updates for controlled entities. So, we must
                 // perform a lot of tracker updates here to make it all work out.
